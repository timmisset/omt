{
  parserClass="org.intellij.sdk.language.parser.OMTParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="OMT"
  psiImplClassSuffix="Impl"
  psiPackage="com.misset.opp.omt.psi"
  psiImplPackage="com.misset.opp.omt.psi.impl"

  elementTypeHolderClass="com.misset.opp.omt.psi.OMTTypes"
  elementTypeClass="com.misset.opp.omt.psi.OMTElementType"
  tokenTypeClass="com.misset.opp.omt.psi.OMTTokenType"

  psiImplUtilClass="com.misset.opp.omt.psi.impl.OMTPsiImplUtil"
}

// the end of the file (or the entire file) can be a (set of) comment(s)
OMTFile ::= (leading? block)*

// a block is a yaml block consisting of a propertyLabel (key): and a sequence, a map or a scalar
block ::=                                   (specificBlock | blockEntry)+
blockEntry ::=                              propertyLabel (map | sequence | scalar)
propertyLabel ::=                           PROPERTY

// a scalar must follow the property label directly but can be multiple lines
// it is not affected by indentation
scalar ::=                                  (scalarValue) (ODT_END | trailing)+
scalarValue ::=                             constant_value | parameterWithType | script | variableAssignment | queryPath

// a sequence must start with a newline followed by items, lead by their bullet (-)
// indentation is allowed but not required. If indentToken, it must dedentToken
sequence ::=                                trailing ((indentToken sequenceItem* dedentToken) | sequenceItem*)
sequenceItem ::=                            leading? SEQUENCE_BULLET? sequenceItemValue (ODT_END | trailing)+
sequenceItemValue ::=                       parameterWithType | variableAssignment | queryPath

// a map is nothing more than another block, it must however be indented
map ::=                                     trailing indentToken block dedentToken

// SPECIFIC BLOCKS
specificBlock ::=                          importBlock | exportBlock | prefixBlock | queriesBlock | commandsBlock | modelBlock | moduleBlock
// todo: check if this can be placed by a generic parser that will throw exceptions based on the content but
// still using the generic scalar, sequence or map

// sequences
exportBlock ::=                             EXPORT_START trailing ((indentToken memberList dedentToken) | memberList)?
memberList ::=                              (SEQUENCE_BULLET member trailing)*
member ::=                                  NAME     {
                                                       mixin="com.misset.opp.omt.psi.impl.OMTMemberNamedElementImpl"
                                                       implements="com.misset.opp.omt.psi.named.OMTMemberNamedElement"
                                                       methods=[getName setName getNameIdentifier]
                                                     }

// scalars
queriesBlock::=                             QUERY_BLOCK_START (PIPE trailing defineQueryStatement* ODT_END)?
commandsBlock::=                            COMMAND_BLOCK_START (PIPE trailing defineCommandStatement* ODT_END)?

moduleBlock::=                              leading? MODULE_NAME_START moduleName trailing
moduleName::=                               NAME | OPERATOR

// maps
importBlock ::=                             leading? IMPORT_START trailing (indentToken import* dedentToken)?
import ::=                                  leading? importSource trailing ((indentToken memberList dedentToken) | memberList)?
importSource ::=                            leading? STRING COLON | IMPORT_PATH EMPTY_ARRAY? trailing

prefixBlock::=                              PREFIX_BLOCK_START trailing (indentToken prefix* dedentToken)?
prefix::=                                   leading? namespacePrefix IRI trailing
namespacePrefix::=                          PROPERTY | (NAMESPACE COLON)            {
                                                                                         mixin="com.misset.opp.omt.psi.impl.OMTNamespacePrefixNamedElementImpl"
                                                                                         implements="com.misset.opp.omt.psi.named.OMTNamespacePrefixNamedElement"
                                                                                         methods=[getName setName getNameIdentifier]
                                                                                   }
curieElement ::=                            namespacePrefix NAMESPACE_MEMBER       { methods = [getPrefix isDefinedByPrefix]}
curieConstantElement ::=                    CURIE_CONSTANT_ELEMENT_PREFIX curieElement

modelBlock::=                               MODEL_BLOCK_START trailing (indentToken modelItemBlock+ dedentToken)?
modelItemBlock::=                           leading? modelItemLabel trailing (indentToken block dedentToken)?
modelItemLabel::=                           propertyLabel modelItemTypeElement
modelItemTypeElement ::=                    MODEL_ITEM_TYPE

// COMMENTS
// Can occur on empty lines (JavaDocs and End Of Line Comments) or at the end of lines (End of Line Comments)
comment ::=                                 END_OF_LINE_COMMENT | JAVA_DOCS
eolComment ::=                              END_OF_LINE_COMMENT
// trailing is everything at the end of the current line and before NEW_LINE.
// It can be simply the NEW_LINE or an eolComment followed by a NEW_LINE
trailing ::=                                eolComment? NEW_LINE+
// leading is everything before a block or item. Assuming that comments are written above the code they are
// commenting on, this should help to relate the comment to the code
leading ::=                                 (comment NEW_LINE)+

// ////////////////////////////////////////////////////
// ODT
// ////////////////////////////////////////////////////
constant_value ::=                          STRING | INTEGER | DECIMAL | NULL | BOOLEAN | TYPED_VALUE
// a variable is declared using VAR and one or more variable names. Optionally an assignment is added
// the assignment is deconstructed to the entire set of variables that is declared. i.e. VAR $a, $b = [1, 2]. $a == 1, $b == 2
// or can be VAR $a = 1, $b = 2 etc. todo: check if this is actually true
declareVariable ::=                         DECLARE_VAR (variableAssignment | variable) (COMMA (variableAssignment | variable))*
// a variable assignment is $var = 1234
variableAssignment::=                       variable EQUALS variableValue
// a variable can be assigned with anything
variableValue ::=                           constant_value | queryPath | commandCall

// a parameter type is used to typecast input parameters in OMT model items
variable ::=                                VARIABLE_NAME | declaredVariable | globalVariable {
                                                                                 mixin="com.misset.opp.omt.psi.impl.OMTVariableNamedElementImpl"
                                                                                 implements="com.misset.opp.omt.psi.named.OMTVariableNamedElement"
                                                                                 methods=[getName setName isDeclaredVariable isGlobalVariable getNameIdentifier]
                                                                               }
// the lexer should determine if operating in a state of declare and provide a difference response for the discovered variable name
declaredVariable ::=                        DECLARED_VARIABLE_NAME
globalVariable ::=                          GLOBAL_VARIABLE_NAME
parameterWithType ::=                       variable PARENTHESES_OPEN parameterType PARENTHESES_CLOSE
parameterType ::=                           IRI | (namespacePrefix NAMESPACE_MEMBER) {
    methods = [isDefinedByPrefix]
}

// INDENTATION
dedentToken ::=                            DEDENT | DEDENT2
indentToken ::=                            INDENT | INDENT2

// SCRIPT
// an ODT (script) block is always started by a Yaml scalar node
// it can start on the same line and be restricted to that line (not required) or it can be started by the
// literal indentifier, the "|" in Yaml. In which case it should be followed by an empty line and indentToken and dedentToken
script ::=                                  PIPE trailing scriptLine*
commandBlock ::=                            CURLY_OPEN trailing (script | scriptLine+) CURLY_CLOSED
// a scriptline is contained by the addition of the semicolon at the end
scriptLine ::=                              leading? ((scriptContent SEMICOLON) | commandBlock | logicalBlock) trailing
// the contents of a script, contained by a scriptLine or Scalar
scriptContent ::=                           declareVariable | variableAssignment | definePrefix | commandCall | assignmentStatement |
                                            addToCollection | removeFromCollection | logicalBlock | returnStatement

// DEFINED MEMBERS
// ODT Members are Operators and Commands, both can be created by a DEFINE statement
// there is also a collection of BuiltIn operators and commands which are included
// and finally, all runnable OMT modelitems are available as Commands (Activity, Procedure) or Operators (StandAloneQuery)
// only the Defined members are part of set of the grammar parser
defineName ::=                              NAME | OPERATOR                         {
                                                                                       mixin="com.misset.opp.omt.psi.impl.OMTMemberNamedElementImpl"
                                                                                       implements="com.misset.opp.omt.psi.named.OMTMemberNamedElement"
                                                                                       methods=[getName setName getNameIdentifier]
                                                                                     }
defineQueryStatement ::=                    leading? DEFINE_START DEFINE_QUERY defineName defineParam? LAMBDA queryPath SEMICOLON trailing
defineCommandStatement ::=                  leading? DEFINE_START DEFINE_COMMAND defineName defineParam? LAMBDA commandBlock trailing
definePrefix ::=                            leading? PREFIX_DEFINE_START prefix trailing
defineParam ::=                             PARENTHESES_OPEN (variable (COMMA variable)*)? PARENTHESES_CLOSE

// MEMBER CALLS
// A call to either an Operator or a Command. In case of the latter, it's always prefixed with @
operatorCall ::=                            (OPERATOR | CONDITIONAL_OPERATOR | NAME) signature? {
                                                             mixin="com.misset.opp.omt.psi.impl.OMTMemberNamedElementImpl"
                                                             implements="com.misset.opp.omt.psi.named.OMTMemberNamedElement"
                                                             methods=[getName setName getNameIdentifier]
                                                           }
commandCall ::=                             COMMAND flagSignature? signature?
                                                            {
                                                             mixin="com.misset.opp.omt.psi.impl.OMTMemberNamedElementImpl"
                                                             implements="com.misset.opp.omt.psi.named.OMTMemberNamedElement"
                                                             methods=[getName setName getNameIdentifier]
                                                           }
signature ::=                               PARENTHESES_OPEN (variableValue (COMMA variableValue)*)? PARENTHESES_CLOSE
flagSignature ::=                           FLAG

logicalBlock ::=                            ifBlock commandBlock (ELSE_OPERATOR ifBlock commandBlock)* elseBlock?
ifBlock ::=                                 IF_OPERATOR (queryPath | (PARENTHESES_OPEN queryPath PARENTHESES_CLOSE))
elseBlock ::=                               ELSE_OPERATOR (queryPath | (PARENTHESES_OPEN queryPath PARENTHESES_CLOSE))
returnStatement ::=                         RETURN_OPERATOR queryPath?

// an equation statement should contain a left hand value and 1+ condition operators + right hand values:
// $value == $value == $value etc...
equationStatement ::=                       (CONDITIONAL_OPERATOR queryStep)+
assignmentStatement ::=                     queryPath trailing? EQUALS trailing? (queryPath | commandCall)
addToCollection ::=                         queryPath trailing? ADD trailing? (queryPath | commandCall)
removeFromCollection ::=                    queryPath trailing? REMOVE trailing? (queryPath | commandCall)

// QUERIES
// A queryPath consists of one or more querySteps. A queryStep can be considered forward or reverse (indicated by ^)
// to reduce the complexity of parsing, slashes will be captured but are not required
queryPath ::=                               (FORWARD_SLASH? (queryStep | queryReverseStep))+ (PIPE queryPath)?
queryStep ::=                               equationStatement | constant_value | variable | curieConstantElement | curieElement |
                                            operatorCall | IRI | DOT | queryOneOrMany | queryZeroOrMany | queryWrapper | CONDITIONAL_OPERATOR |
                                            LAMBDA | queryFilter | NEW_LINE
queryReverseStep ::=                        CARAT queryStep

// a query filter is contained by brackets [] and should resolve to boolean
queryFilter ::=                             BRACKET_OPEN queryPath BRACKET_CLOSED

// a recursion will continuously collect items based on the outcome of the previous recursion and the path described in the recursion
// this makes it easy to traverse a graph for nested elements of identical/similar design
queryWrapper ::=                            PARENTHESES_OPEN queryPath PARENTHESES_CLOSE
// one or more will not return itself
queryOneOrMany ::=                          queryWrapper PLUS
// zero or more will return itself and all descendents
queryZeroOrMany ::=                         queryWrapper ASTERIX

